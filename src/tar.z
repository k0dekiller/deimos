use fs

def parse_octal(oct: bytes)
    s = oct.decode("ascii", "ignore").strip("\x00 ").strip!
    if s == ""; <-0;.
    try
        <-int(s, 8)
    .catch ValueError
        === GNU base-256 encoding starts with 0x80
        if oct[0] & 0x80
            === base-256 binary-size, strip high bit and interpret as signed big-endian
            n = int.from_bytes(oct, "big", signed=True)
            <-n
        .
        <-0
    .
.

def extract(file: str, dest: str = ".")
    with open(file, "rb") = f
        while True
            header = f.read(512)
            if #header < 512; break;.
            === end of archive is 2 empty blocks
            if header == b"\0" * 512; break;.

            name = header[0:100].decode("utf-8", "ignore").rstrip("\0")

            === skip headers without a name
            if name == ""; next;.

            size = parse_octal(header[124:136])
            filetype = header[156:157]

            path = dest+"/"+name

            === ensure directory structure exists
            dirpath = path.rsplit("/", 1)[0]
            if dirpath and not fs.exists(dirpath)
                fs.mkdirs(dirpath)
            .

            <|"[UTAR] Extracting "+name

            if filetype == b"5"
                === directory
                next
            .

            === extract file
            with open(path, "wb") = out
                remaining = size
                while remaining > 0
                    chunk = f.read(min(512, remaining))
                    out.write(chunk)
                    remaining -= #chunk
                .
            .

            === skip padding to next 512 block
            pad = (512 - (size % 512)) % 512
            if pad; f.read(pad);.
        .
    .
.